// BitCodeEmitter.cs
//
// Author:
//   Ming Zhou  <zhoux738@umn.edu>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.Collections.Generic;
using System.Threading;

using Mono.Compiler;
using SimpleJit.Metadata;
using SimpleJit.CIL;

using LLVMSharp;

/// <summary>
///   Emit LLVM bitcode via LLVMSharp.
/// </summary>
namespace Mono.Compiler.BigStep.LLVMBackend {
	public class BitCodeEmitter : IOperationProcessor {
		private static readonly LLVMBool Success = new LLVMBool (0);
		private static readonly LLVMBool True = new LLVMBool (1);
		private static readonly LLVMMCJITCompilerOptions s_options = new LLVMMCJITCompilerOptions { NoFramePointerElim = 0 };

		private static int s_moduleSeq;
		private static bool s_initialized;

		private LLVMModuleRef module;
		private LLVMBuilderRef builder;
		private LLVMValueRef function;

		private LLVMValueRef[] argAddrs;
		private LLVMValueRef[] localAddrs;
		private Dictionary<string, LLVMValueRef> temps;
		private Dictionary<string, LLVMBasicBlockRef> bbs;

                private LLVMBasicBlockRef currentbb;

                // Provides a one-time use temp name. The values generated by this name 
                // should be used immediately and not preserved across lexical scopes.
                private string NextTempName => "R" + Interlocked.Increment(ref tempSeq);
                private int tempSeq = 0;

		public bool PrintDebugInfo { get; set; }
		public bool VerifyGeneratedCode { get; set; }

		internal MethodInfo MethodInfo { get; }
		internal IRuntimeInformation RuntimeInfo { get; }

		public BitCodeEmitter (IRuntimeInformation runtimeInfo, MethodInfo method)
		{
			RuntimeInfo = runtimeInfo;
			MethodInfo = method;
			int seq = Interlocked.Increment (ref s_moduleSeq);
			string modName = "llvmmodule_" + seq;
			module = LLVM.ModuleCreateWithName(modName);
			builder = LLVM.CreateBuilder ();
			temps = new Dictionary<string, LLVMValueRef> ();
			bbs = new Dictionary<string, LLVMBasicBlockRef> ();

			IReadOnlyCollection<ParameterInfo> prms = method.Parameters;
			LLVMTypeRef[] largs = new LLVMTypeRef[prms.Count];
			int i = 0;
			foreach (ParameterInfo pinfo in prms) 
                        {
				largs[i] = TranslateType (pinfo.ParameterType);
				i++;
			}
			LLVMTypeRef rtyp = TranslateType (method.ReturnType);

			var funTy = LLVM.FunctionType (rtyp, largs, false);
			string funcName = modName + "_" + method.Name;
			function = LLVM.AddFunction (module, funcName, funTy);
			CreateFirstBasicBlock ();

			IList<LocalVariableInfo> locals = method.Body.LocalVariables;
			AllocateArgsAndLocals (largs, locals);
		}

		/// <summary>
                /// Produce a native handle for the generated native code. Call this after Symbolic Executor finishes Execute().
		/// </summary>
                public NativeCodeHandle Yield ()
		{
			if (PrintDebugInfo)
				LLVM.DumpModule (module);

			if (!BitCodeEmitter.s_initialized) {
				lock (typeof (BitCodeEmitter)) {
					if (!BitCodeEmitter.s_initialized) {
						BigStep.InitializeLLVM_OSX_AMD64 (s_options);

						BitCodeEmitter.s_initialized = true;
						//Console.WriteLine("[DEBUG] LLVM initialized.");
					}
				}
			}

			try {
				if (VerifyGeneratedCode) {
					if (LLVM.VerifyFunction (function, LLVMVerifierFailureAction.LLVMPrintMessageAction) != Success)
						throw new Exception ($"Couldn't verify the generated code. There is likely due to bug in code generation.");
				}

				if (LLVM.CreateMCJITCompilerForModule(out LLVMExecutionEngineRef engine, module, s_options, out var error) != Success)
					throw new Exception ($"Compilation by LLVM failed: { error }");
				//Console.WriteLine("[DEBUG] LLVM compilation succeeded.");
				IntPtr fnptr = LLVM.GetPointerToGlobal (engine, function);
				unsafe {
					return new NativeCodeHandle((byte*)fnptr, -1);
				}
			} finally {
				LLVM.DisposeBuilder(builder);
			}
		}

		/// <summary>
                /// Emit LLVM instruction per CIL operation.
		/// </summary>
                public void Process (OperationInfo opInfo)
		{
                        int pcIndex = opInfo.Index;
			if (opInfo.JumpTarget) {
				// If this op is a jump target, conclude the current BB and start a new one
                                LLVMBasicBlockRef prevbb = currentbb;
                                LLVMValueRef term = prevbb.GetBasicBlockTerminator();
                                if (term.Equals(default(LLVMValueRef)))
                                {
                                        // We don't have terminator yet. Create one.
				        currentbb = this.GetOrAddBasicBlock (pcIndex, false);
                                        LLVM.BuildBr(builder, currentbb);
                                        LLVM.PositionBuilderAtEnd (builder, currentbb);
                                }
                                else
                                {
				        currentbb = this.GetOrAddBasicBlock (pcIndex, true);
                                }
			}

			Opcode op = opInfo.Operation;
			ExtendedOpcode? exop = opInfo.ExtOperation;
			IOperand[] operands = opInfo.Operands;

			// The result is the value pushed onto the stack by CLR at the end of instruction.
			// In the translation we treat each new frame on the stack as a distinct instance
			// that corresponds to a register in LLVM. If a frame is popped and pushed again it
			// becomes a new instance.
			//
			// CLR eval-stack frame = TempOperand = LLVM temp register
			//
			// If the result is non-null, we must generate a new temp value and associate it
			// with the temp operand's name. When a temp operand appears in the operands, it
			// means a previously pushed value is being consumed by instruction. Based on the
			// name of the operand we can  retrieve the temp register and use that in LLVM
			// operation.
			string tempName = opInfo.Result?.Name;

                        if (exop.HasValue)
                        {
                                switch (exop.Value) 
                                {
                                case ExtendedOpcode.Cgt: 
                                        // compare greater than
                                        // tmp, tmp => result
                                        InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp;
                                                                if (this.hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                                                                {
                                                                        tmp = LLVM.BuildFCmp (builder, LLVMRealPredicate.LLVMRealOGT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                else
                                                                {
                                                                        tmp = LLVM.BuildICmp (builder, LLVMIntPredicate.LLVMIntSGT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                        break;
                                case ExtendedOpcode.CgtUn:
                                        // compare greater than, unsigned
                                        // tmp, tmp => result
                                        InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp;
                                                                if (this.hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                                                                {
                                                                        tmp = LLVM.BuildFCmp (builder, LLVMRealPredicate.LLVMRealUGT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                else
                                                                {
                                                                        tmp = LLVM.BuildICmp (builder, LLVMIntPredicate.LLVMIntUGT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                        break;
                                case ExtendedOpcode.Clt: 
                                        // compare less than
                                        // tmp, tmp => result
                                        InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp;
                                                                if (this.hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                                                                {
                                                                        tmp = LLVM.BuildFCmp (builder, LLVMRealPredicate.LLVMRealOLT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                else
                                                                {
                                                                        tmp = LLVM.BuildICmp (builder, LLVMIntPredicate.LLVMIntSLT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                        break;
                                case ExtendedOpcode.CltUn: 
                                        // compare less than, unsigned
                                        // tmp, tmp => result
                                        InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp;
                                                                if (this.hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                                                                {
                                                                        tmp = LLVM.BuildFCmp (builder, LLVMRealPredicate.LLVMRealULT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                else
                                                                {
                                                                        tmp = LLVM.BuildICmp (builder, LLVMIntPredicate.LLVMIntULT, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                        break;
                                case ExtendedOpcode.Ceq: 
                                        // compare equal to
                                        // tmp, tmp => result
                                        InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp;
                                                                if (this.hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                                                                {
                                                                        tmp = LLVM.BuildFCmp (builder, LLVMRealPredicate.LLVMRealOEQ, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                else
                                                                {
                                                                        tmp = LLVM.BuildICmp (builder, LLVMIntPredicate.LLVMIntEQ, vm.Temp0, vm.Temp1, tempName);
                                                                }
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                        break;
                                default:
                                        throw new NotImplementedException($"Unexpected. CIL operation { exop } is not implemented yet.");
                                }

                                return;
                        }

			switch (op) {
                        // Notation for comments:
                        // op1, op2, ... => result pushed into expr-stack
                        case Opcode.Nop:
                                break;
                        case Opcode.Ret:
                                // tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                if (operands.Length > 0) {
                                                                        LLVM.BuildRet (builder, vm.Temp0);
                                                                } else {
                                                                        LLVM.BuildRetVoid (builder);
                                                                }
                                                        });
                                break;
                        case Opcode.Ldarg0:
                        case Opcode.Ldarg1:
                        case Opcode.Ldarg2:
                        case Opcode.Ldarg3:
                        case Opcode.LdargS:
                                // arg => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildLoad (builder, vm.Address0, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Stloc0:
                        case Opcode.Stloc1:
                        case Opcode.Stloc2:
                        case Opcode.Stloc3:
                                // tmp, local
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVM.BuildStore (builder, vm.Temp0, vm.Address1);
                                                        });
                                break;
                        case Opcode.StargS:
                                // store a value in an argument slot (short offset)
                                // tmp, arg
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVM.BuildStore (builder, vm.Temp0, vm.Address1);
                                                        });
                                break;
                        case Opcode.LdcI4:
                        case Opcode.LdcI4_0:
                        case Opcode.LdcI4_1:
                        case Opcode.LdcI4_2:
                        case Opcode.LdcI4_3:
                        case Opcode.LdcI4_4:
                        case Opcode.LdcI4_5:
                        case Opcode.LdcI4_6:
                        case Opcode.LdcI4_7:
                        case Opcode.LdcI4_8:
                        case Opcode.LdcI4M1:
                        case Opcode.LdcI4S:
                                // const => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                // LLVM doesn't allow assignment from constant to value.
                                                                // So we just pretend that the constant is a temp value.
                                                                // When it's used in an instruction it will be realized
                                                                // in the form of "ty value-literal" (e.g. "i32 42")
                                                                LLVMValueRef tmp = vm.Const0;
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Ldloc0:
                        case Opcode.Ldloc1:
                        case Opcode.Ldloc2:
                        case Opcode.Ldloc3:
                        case Opcode.LdlocS:
                                // local => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildLoad (builder, vm.Address0, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
				case Opcode.Ldsfld:
					// const => tmp
					int token = (operands[0] as Int32ConstOperand).Value;
					InvokeOperation (op, exop, operands,
							 vm => {
								 // TODO: It would be nice if operand[0] just carried the fieldInfo here
								 FieldInfo fieldInfo = RuntimeInfo.GetFieldInfoForToken (MethodInfo, token);

								 LLVMValueRef fieldAddress = GetConstValue (RuntimeInfo.ComputeFieldAddress (fieldInfo));

								 LLVMTypeRef fieldType = LLVM.Int32Type (); /* FIXME: get from field info */
								 LLVMValueRef address = LLVM.ConstIntToPtr (fieldAddress, LLVM.PointerType (fieldType, 0));
								 LLVMValueRef tmp = LLVM.BuildLoad (builder, address, tempName);
								 return new NamedTempValue (tmp, tempName);
							 });
					break;
                        case Opcode.Add:
                        case Opcode.AddOvf: // TODO - Handle overflow
                        case Opcode.AddOvfUn: // TODO - Handle overflow, unsigned
                                // tmp, tmp => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildAdd (builder, vm.Temp0, vm.Temp1, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Sub:
                        case Opcode.SubOvf: // TODO - Handle overflow
                        case Opcode.SubOvfUn: // TODO - Handle overflow, unsigned
                                // tmp, tmp => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildSub (builder, vm.Temp0, vm.Temp1, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Mul:
                        case Opcode.MulOvf: // TODO - Handle overflow
                        case Opcode.MulOvfUn: // TODO - Handle overflow, unsigned
                                // tmp, tmp => tmp
                                InvokeOperation(op, exop, operands,
                                                vm => {
                                                        LLVMValueRef tmp = LLVM.BuildMul (builder, vm.Temp0, vm.Temp1, tempName);
                                                        return new NamedTempValue (tmp, tempName);
                                                });
                                break;
                        case Opcode.Div:
                                // tmp, tmp => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildFDiv (builder, vm.Temp0, vm.Temp1, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.DivUn:
                                // tmp, tmp => tmp
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMValueRef tmp = LLVM.BuildUDiv (builder, vm.Temp0, vm.Temp1, tempName);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Br:
                        case Opcode.BrS:
                                LLVM.BuildBr(builder, this.GetBranchTarget (operands[0]));
                                break;
                        case Opcode.Brtrue:
                        case Opcode.BrtrueS:
                                // branch on true (int value != 0)
                                // tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMBasicBlockRef bbTrue = this.GetBranchTarget (operands[1]);
                                                                LLVMBasicBlockRef bbFalse = this.GetImplicitBranchTarget (pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, vm.Temp0, bbTrue, bbFalse);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });   
                                break;
                        case Opcode.Brfalse:
                        case Opcode.BrfalseS:
                                // branch on false (int value = 0)
                                // tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                LLVMBasicBlockRef bbTrue = this.GetBranchTarget (operands[1]);
                                                                LLVMBasicBlockRef bbFalse = this.GetImplicitBranchTarget (pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, vm.Temp0, bbTrue, bbFalse);
                                                                return new NamedTempValue (tmp, tempName);
                                                        });
                                break;
                        case Opcode.Beq:
                        case Opcode.BeqS:
                                // branch on ==
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealOEQ, LLVMIntPredicate.LLVMIntEQ, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.BneUn:
                        case Opcode.BneUnS:
                                // branch on !=, unsigned
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealUNE, LLVMIntPredicate.LLVMIntNE, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.Ble:
                        case Opcode.BleS:
                                // branch on <=
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealOLE, LLVMIntPredicate.LLVMIntSLE, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.BleUn:
                        case Opcode.BleUnS:
                                // branch on <=, unsigned
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealULE, LLVMIntPredicate.LLVMIntULE, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.Blt:
                        case Opcode.BltS:
                                // branch on <
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealOLT, LLVMIntPredicate.LLVMIntSLT, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.BltUn:
                        case Opcode.BltUnS:
                                // branch on <, unsigned
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealULT, LLVMIntPredicate.LLVMIntULT, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.Bge:
                        case Opcode.BgeS:
                                // branch on >=
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealOGE, LLVMIntPredicate.LLVMIntSGE, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.BgeUn:
                        case Opcode.BgeUnS:
                                // branch on >=, unsigned
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealUGE, LLVMIntPredicate.LLVMIntUGE, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;
                        case Opcode.Bgt:
                        case Opcode.BgtS:
                                // branch on >
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (LLVMRealPredicate.LLVMRealOGT, LLVMIntPredicate.LLVMIntSGT, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;     
                        case Opcode.BgtUn:
                        case Opcode.BgtUnS:
                                // branch on >, unsigned
                                // tmp, tmp, pc
                                InvokeOperation (op, exop, operands,
                                                        vm => {
                                                                var tuple = CompareAndJumpTo (
                                                                        LLVMRealPredicate.LLVMRealUGT, LLVMIntPredicate.LLVMIntUGT, operands, vm, pcIndex);
                                                                LLVMValueRef tmp = LLVM.BuildCondBr (builder, tuple.Item1, tuple.Item2, tuple.Item3);
                                                        });
                                break;                                 
                        default:
                                throw new NotImplementedException($"Unexpected. CIL operation { op } is not implemented yet.");
			}
		}

		internal class ValueMappings {
			internal LLVMValueRef Const0 {
				get { return Values[0].Value; }
			}

			internal LLVMValueRef Address0 {
				get { return Values[0].Value; }
			}

			internal LLVMValueRef Address1 {
				get { return Values[1].Value; }
			}

			internal LLVMValueRef Temp0 {
				get { return Values[0].Value; }
			}

			internal LLVMValueRef Temp1 {
				get { return Values[1].Value; }
			}

			internal StorageTypedValue[] Values { get; private set; }

			internal ValueMappings (int length)
			{
				Values = new StorageTypedValue[length];
			}
		}

		internal enum StorageType {
			Address,
			Temp,
			Const
		}

		internal class StorageTypedValue {
			internal StorageType Type { get; set; }
			internal LLVMValueRef Value { get; set; }
		}

		internal class NamedTempValue {
			internal string Name { get; set; }
			internal LLVMValueRef Value { get; set; }

			internal NamedTempValue (LLVMValueRef value, string name = null)
			{
				this.Value = value;
				this.Name = name;
			}
		}

		private void AllocateArgsAndLocals (LLVMTypeRef[] args, IList<LocalVariableInfo> locals)
		{
			this.argAddrs = new LLVMValueRef[args.Length];
			uint i = 0;
			for (; i < args.Length; i++) {
				LLVMValueRef vref = LLVM.GetParam (function, i);
				LLVMValueRef vaddr = LLVM.BuildAlloca (builder, args[i], "A" + i);
				LLVM.BuildStore (builder, vref, vaddr);
				this.argAddrs[i] = vaddr;
			}

			i = 0;
			localAddrs = new LLVMValueRef[locals.Count];
			foreach (LocalVariableInfo lvi in locals) {
				LLVMTypeRef ltyp = TranslateType (lvi.LocalType);
				LLVMValueRef lref = LLVM.BuildAlloca (builder, ltyp, "L" + i);
				this.localAddrs[i++] = lref;
			}
		}

                private Tuple<LLVMValueRef, LLVMBasicBlockRef, LLVMBasicBlockRef> CompareAndJumpTo (
                        LLVMRealPredicate rprd, LLVMIntPredicate prd, IOperand[] operands, ValueMappings vm, int pcIndex)
                {
                        // 1) Comapre the two values and store the result in an LLVM auto temp
                        LLVMValueRef cmpResult;
                        if (hasAtLeastOneFloat(vm.Temp0, vm.Temp1))
                        {
                                cmpResult = LLVM.BuildFCmp (builder, rprd, vm.Temp0, vm.Temp1, NextTempName);
                        }
                        else
                        {
                                cmpResult = LLVM.BuildICmp (builder, prd, vm.Temp0, vm.Temp1, NextTempName);
                        }

                        // 2) True:  the target
                        //    False: next op
                        LLVMBasicBlockRef bbTrue = this.GetBranchTarget (operands[2]);
                        LLVMBasicBlockRef bbFalse = this.GetImplicitBranchTarget (pcIndex);

                        return new Tuple<LLVMValueRef, LLVMBasicBlockRef, LLVMBasicBlockRef>(cmpResult, bbTrue, bbFalse);
                }

                private bool hasAtLeastOneFloat(LLVMValueRef v1, LLVMValueRef v2)
                {
                        LLVMTypeRef typ0 = v1.TypeOf ();
                        LLVMTypeRef typ1 = v2.TypeOf ();
                        return typ0.Equals (LLVMTypeRef.FloatType()) || 
                                typ1.Equals (LLVMTypeRef.FloatType()) || 
                                typ0.Equals (LLVMTypeRef.DoubleType()) || 
                                typ1.Equals (LLVMTypeRef.DoubleType());
                }

		/// Invoke an LLVM operation with given value mappings.
		/// The operation is supposed to return a temp value to be stored.
		private void InvokeOperation (Opcode op, ExtendedOpcode? exop, IOperand[] operands, Func<ValueMappings, NamedTempValue> emitFunc)
		{
			if (this.PrintDebugInfo) 
                        {
				string opstr = $"[DEBUG] {op.ToString()} - ";
				foreach (IOperand od in operands)
                                {
					opstr += od.Name;
                                        if (od.OperandType == OperandType.PC) 
                                        {
                                               opstr += "(" + ((BranchTargetOperand)od).PC + ")";
                                        }
					opstr += " ";
				}
				Console.WriteLine (opstr);
			}

			ValueMappings mappings = new ValueMappings (operands.Length);
			StorageTypedValue[] stvalues = mappings.Values;
			for (int i = 0; i < operands.Length; i++) 
                        {
				IOperand operand = operands[i];
				stvalues[i] = MakeStorageTypedValue (operand);
			}

			NamedTempValue ntv = emitFunc (mappings);
			if (ntv != null) 
                        {
				string name = ntv.Name;
				if (name == null) 
                                        name = LLVM.GetValueName (ntv.Value);

				temps[name] = ntv.Value;
			}
		}

		/// Invoke an LLVM operation with given value mappings.
		/// The operation doesn't produce new temp values.
		private void InvokeOperation (Opcode op, ExtendedOpcode? exop, IOperand[] operands, Action<ValueMappings> emitFunc)
		{
			InvokeOperation (op, exop, operands,
					 (vm) => {
						 emitFunc (vm);
						 return null;
					 });
		}

		private StorageTypedValue MakeStorageTypedValue (IOperand operand)
		{
			LLVMValueRef value = default (LLVMValueRef);
			StorageType stype = default (StorageType);
			switch (operand.OperandType) 
                        {
                        case OperandType.Temp:
                                stype = StorageType.Temp;
                                value = GetTempValue (operand);
                                break;
                        case OperandType.Local:
                                stype = StorageType.Address;
                                value = GetLocalAddr (operand);
                                break;
                        case OperandType.Argument:
                                stype = StorageType.Address;
                                value = GetArgAddr (operand);
                                break;
                        case OperandType.Const:
                                stype = StorageType.Const;
                                value = GetConstValue (operand);
                                break;
			}
			return new StorageTypedValue {
				Type = stype,
				Value = value
			};
		}

		private LLVMBasicBlockRef GetBranchTarget (IOperand operand)
		{
			BranchTargetOperand bto = (BranchTargetOperand)operand;
			int target = bto.PC;
			return GetOrAddBasicBlock (target, false);
		}

                private LLVMBasicBlockRef GetImplicitBranchTarget (int index)
		{
			int target = index + 1;
			return GetOrAddBasicBlock (target, false);
		}

		private LLVMValueRef GetArgAddr (IOperand operand)
		{
			ArgumentOperand aod = (ArgumentOperand)operand;
			return this.argAddrs[aod.Index];
		}

		private LLVMValueRef GetLocalAddr (IOperand operand)
		{
			LocalOperand lod = (LocalOperand)operand;
			return this.localAddrs[lod.Index];
		}

		private LLVMValueRef GetTempValue (IOperand operand)
		{
			TempOperand tod = (TempOperand)operand;
			string name = tod.Name;
			return temps[tod.Name];
		}

		private LLVMValueRef GetConstValue (IOperand operand)
		{
			ConstOperand cod = (ConstOperand)operand;
			if (cod is Int32ConstOperand) {
				return LLVM.ConstInt (LLVM.Int32Type (), (ulong)((Int32ConstOperand)cod).Value, true);
			}
			if (cod is Int64ConstOperand) {
				return LLVM.ConstInt (LLVM.Int64Type (), (ulong)((Int64ConstOperand)cod).Value, true);
			}
			if (cod is Float32ConstOperand)
			{
				return LLVM.ConstReal (LLVM.FloatType (), ((Float32ConstOperand)cod).Value);
			}
			if (cod is Float64ConstOperand) {
				return LLVM.ConstReal (LLVM.FloatType (), ((Float64ConstOperand)cod).Value);
			}

			throw new Exception ("Unexpected. The const operand is tno recognized.");
		}

		private LLVMValueRef GetConstValue (IntPtr constant)
		{
			return LLVM.ConstInt (TranslateType (RuntimeInformation.NativeIntType), (ulong)constant, true);
		}

		private static LLVMTypeRef TranslateType (ClrType ctyp)
		{
			if (ctyp == RuntimeInformation.BoolType) {
				return LLVM.Int1Type ();
			}
			if (ctyp == RuntimeInformation.Int8Type) {
				return LLVM.Int8Type ();
			}
			if (ctyp == RuntimeInformation.Int16Type || ctyp == RuntimeInformation.Int8Type) {
				return LLVM.Int16Type ();
			}
			if (ctyp == RuntimeInformation.Int32Type || ctyp == RuntimeInformation.UInt16Type) {
				return LLVM.Int32Type();
			}
			if (ctyp == RuntimeInformation.Int64Type || ctyp == RuntimeInformation.UInt32Type) {
				return LLVM.Int64Type ();
			}
			if (ctyp == RuntimeInformation.CharType) {
				return LLVM.Int16Type (); // Unicode
			}
			if (ctyp == RuntimeInformation.Float32Type || ctyp == RuntimeInformation.Float64Type) {
				return LLVM.FloatType ();
			}
			if (ctyp == RuntimeInformation.NativeIntType || ctyp == RuntimeInformation.NativeUnsignedIntType) {
				/* FIXME: target platform dependent */
				return LLVM.Int64Type ();
			}
			if (ctyp == RuntimeInformation.StringType) {
				return LLVM.PointerType(LLVM.Int16Type (), 0); // 0 = default address sapce
			}
			if (ctyp == RuntimeInformation.VoidType) {
				return LLVM.VoidType();
			}

			Type typ = ctyp.AsSystemType;
			if (typ.IsClass) {
				return LLVM.PointerType(LLVM.Int64Type (), 0); // 0 = default address sapce
			}

			throw new Exception ($"TODO: Cannot handle type { typ.Name } yet.");
		}

		#region Basic Block operations
		private void CreateFirstBasicBlock ()
		{
			currentbb = LLVM.AppendBasicBlock (function, "entry");
			LLVM.PositionBuilderAtEnd (builder, currentbb);
		}

		private LLVMBasicBlockRef GetOrAddBasicBlock (int opIndex, bool moveToEnd)
		{
			string name = "BB_" + opIndex;
			LLVMBasicBlockRef bbr;
			if (!bbs.TryGetValue (name, out bbr)) {
				bbs[name] = bbr = LLVM.AppendBasicBlock (function, name);
			}

			if (moveToEnd)
				LLVM.PositionBuilderAtEnd (builder, bbr);

			return bbr;
		}
		#endregion
	}
}
